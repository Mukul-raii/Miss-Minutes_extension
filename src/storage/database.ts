import * as sqlite3 from "sqlite3";
import * as path from "path";
import * as fs from "fs";
import { Logger } from "../utils/logger";
import { g } from "@clerk/clerk-react/dist/useAuth-DEP6m3So";
// Structure: "Store-and-Forward" Buffer
// 1. Local DB acts as a flat buffer for activity logs.
// 2. We sync these logs to the backend, which handles Project organization.
export interface ActivityLog {
  id?: number; // Optional: Auto-generated by SQLite
  projectPath: string;
  filePath: string;
  language: string;
  timestamp: number;
  duration: number;
  editor?: string;
  commitHash?: string; // Associated git commit
}

export interface GitCommit {
  id?: number;
  projectPath: string;
  commitHash: string;
  message: string;
  author: string;
  authorEmail: string;
  timestamp: number;
  filesChanged: number;
  linesAdded: number;
  linesDeleted: number;
  branch?: string;
}

export class Database {
  private db: sqlite3.Database | null = null;
  private logger = Logger.getInstance();

  constructor(private storagePath: string) {
    // Initialization is now explicit via init()
  }

  public init(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!fs.existsSync(this.storagePath)) {
        fs.mkdirSync(this.storagePath, { recursive: true });
      }

      const dbPath = path.join(this.storagePath, "codechrono.db");
      this.logger.info(`Initializing database at ${dbPath}`);

      this.db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          this.logger.error("Failed to connect to database", err);
          reject(err);
        } else {
          this.logger.info("Connected to SQLite database");
          this.createTables().then(resolve).catch(reject);
        }
      });
    });
  }

  private createTables(): Promise<void> {
    return new Promise((resolve, reject) => {
      const activitySql = `
      CREATE TABLE IF NOT EXISTS activity_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_path TEXT,
        file_path TEXT,
        language TEXT,
        timestamp INTEGER,
        duration INTEGER,
        editor TEXT,
        commit_hash TEXT
      );
    `;

      const commitSql = `
      CREATE TABLE IF NOT EXISTS git_commits (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_path TEXT,
        commit_hash TEXT UNIQUE,
        message TEXT,
        author TEXT,
        author_email TEXT,
        timestamp INTEGER,
        files_changed INTEGER,
        lines_added INTEGER,
        lines_deleted INTEGER,
        branch TEXT
      );
    `;

      this.db?.run(activitySql, (err) => {
        if (err) {
          this.logger.error("Error creating activity_logs table", err);
          reject(err);
          return;
        }

        this.db?.run(commitSql, (err) => {
          if (err) {
            this.logger.error("Error creating git_commits table", err);
            reject(err);
            return;
          }

          this.logger.info("Database tables initialized");
          // Create indexes for faster sync queries
          this.db?.run(
            "CREATE INDEX IF NOT EXISTS idx_timestamp ON activity_logs(timestamp)",
            (err) => {
              if (err) {
                this.logger.error("Error creating activity index", err);
                reject(err);
              } else {
                this.db?.run(
                  "CREATE INDEX IF NOT EXISTS idx_commit_timestamp ON git_commits(timestamp)",
                  (err) => {
                    if (err) {
                      this.logger.error("Error creating commit index", err);
                      reject(err);
                    } else {
                      resolve();
                    }
                  }
                );
              }
            }
          );
        });
      });
    });
  }

  public insertActivity(log: ActivityLog): Promise<void> {
    return new Promise((resolve, reject) => {
      const sql = `INSERT INTO activity_logs (project_path, file_path, language, timestamp, duration, editor, commit_hash) VALUES (?, ?, ?, ?, ?, ?, ?)`;
      this.db?.run(
        sql,
        [
          log.projectPath,
          log.filePath,
          log.language,
          log.timestamp,
          log.duration,
          log.editor || "vscode",
          log.commitHash || null,
        ],
        (err) => {
          if (err) {
            this.logger.error("Error inserting activity log", err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public insertCommit(commit: GitCommit): Promise<void> {
    return new Promise((resolve, reject) => {
      const sql = `INSERT OR REPLACE INTO git_commits 
        (project_path, commit_hash, message, author, author_email, timestamp, files_changed, lines_added, lines_deleted, branch) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
      this.db?.run(
        sql,
        [
          commit.projectPath,
          commit.commitHash,
          commit.message,
          commit.author,
          commit.authorEmail,
          commit.timestamp,
          commit.filesChanged,
          commit.linesAdded,
          commit.linesDeleted,
          commit.branch || null,
        ],
        (err) => {
          if (err) {
            this.logger.error("Error inserting git commit", err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public getUnsyncedLogs(limit: number = 50): Promise<ActivityLog[]> {
    return new Promise((resolve, reject) => {
      const sql = `SELECT id, project_path as projectPath, file_path as filePath, language, timestamp, duration, editor, commit_hash as commitHash FROM activity_logs ORDER BY timestamp ASC LIMIT ?`;
      this.db?.all(sql, [limit], (err, rows) => {
        if (err) {
          this.logger.error("Error fetching unsynced logs", err);
          reject(err);
        } else {
          resolve(rows as ActivityLog[]);
        }
      });
    });
  }

  public getUnsyncedCommits(limit: number = 20): Promise<GitCommit[]> {
    return new Promise((resolve, reject) => {
      const sql = `SELECT id, project_path as projectPath, commit_hash as commitHash, message, author, author_email as authorEmail, 
        timestamp, files_changed as filesChanged, lines_added as linesAdded, lines_deleted as linesDeleted, branch 
        FROM git_commits ORDER BY timestamp ASC LIMIT ?`;
      this.db?.all(sql, [limit], (err, rows) => {
        if (err) {
          this.logger.error("Error fetching unsynced commits", err);
          reject(err);
        } else {
          resolve(rows as GitCommit[]);
        }
      });
    });
  }

  public deleteLogs(ids: number[]): Promise<void> {
    if (ids.length === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const placeholders = ids.map(() => "?").join(",");
      const sql = `DELETE FROM activity_logs WHERE id IN (${placeholders})`;
      this.db?.run(sql, ids, (err) => {
        if (err) {
          this.logger.error("Error deleting logs", err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  public deleteCommits(ids: number[]): Promise<void> {
    if (ids.length === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const placeholders = ids.map(() => "?").join(",");
      const sql = `DELETE FROM git_commits WHERE id IN (${placeholders})`;
      this.db?.run(sql, ids, (err) => {
        if (err) {
          this.logger.error("Error deleting commits", err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  public close() {
    this.db?.close((err) => {
      if (err) {
        this.logger.error("Error closing database", err);
      }
    });
  }
}
